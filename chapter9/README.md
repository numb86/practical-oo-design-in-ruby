# 第9章　費用対効果の高いテストを設計する

変更可能なコードを書くためには、オブジェクト指向設計についての理解だけでなく、リファクタリングとテストのスキルも不可欠。  
コードが変更可能な構成に設計されていても、実際に変更していくことが出来なければ意味がない。つまり、リファクタリングによってコードを書き換えることが出来てこそ、「変更に強い設計」は意味を持つ。  
そしてリファクタリングを支えるのが、適切に書かれたテスト。

## 9.1 意図を持ったテスト

テストを書くことの目的は、コストの削減。  
テストによって開発効率を上げることで、開発にかかる様々なコストを削減する。  
テストを書くことで得られる価値が、テストを書くコストを下回っているのでは、意味がない。  
効率のよいテストを書けないビギナーは、テストから得られる価値はコストに見合わないと感じ、テストに対して否定的になってしまう。

費用対効果の高いテストを書くためには、テストの意図を明確にすると同時に、何を、いつ、どのようにテストするのかも、理解しておく必要がある。  
そうすることで、テストから得られる価値が、テストを書くコストを上回るようになる。

### テストの意図

何のためにテストを書くのか。

バグの早期発見のため。  
バグの発見と修正は、初期段階であるほど容易である。バグの初期段階での修正は、コスト削減になる。  
バグを修正する過程で、これから実装を進めていく設計に対して理解が深まることもある。

テストはそれ自体が仕様書の役割を果たす。

テストによってリファクタリングが可能になり、それにより設計を意図的に後回しに出来る。  
必要な情報が欠けている状況では、安易に設計せず、暫定的な対応に留めるべき。その際に適切なテストを書いておけば、必要な情報が揃った段階でのリファクタリングを安全に行うことが出来る。

テストはアプリケーションの抽象化を支える。  
よい設計をすると自然と、コード全体の抽象度は上がっていく。そうなると、コードの全体像を理解することは難しくなる。  
そのような状態でも安全にコードに変更を加えるためには、テストが不可欠。

テストを書く行為によって、設計の欠陥を明らかに出来る。  
テストを書くのが難しい場合、コードに問題があるかもしれない。特定のコンテキストでないと使えない、密結合で依存関係を持ち過ぎている、など。  
テストを書くことが、こういった問題に気付くキッカケになり得る。

### 何をテストするのか

少ないコストでテストの恩恵を受けるには、必要なテストのみを書くようにする。

オブジェクト指向設計では、オブジェクト同士の依存は最低限にするのが原則。パブリックインターフェースにのみ依存し、内部の実装には関与しないようにする。そうすることで疎結合になり、変更に強くなる。  
同じことはテストにも言える。  
テストはメッセージにのみ集中し、オブジェクトの内部の実装には関与しない。  
具体的には、オブジェクトが受け付けるメッセージ（受信メッセージ）の戻り値と、オブジェクトが送信するメッセージのなかで副作用のあるもの（コマンドメッセージ）に対して、テストを書く。  
そうすれば、オブジェクトのプライベートな振る舞いをいくら変更してもテストは壊れず、少ないコストで大きなメリットを得られるようになる。

### いつテストするのか

テストを最初に書く「テストファースト」が望ましい。  
特に初心者は、そこから大きな恩恵を受けることが出来る。  
初心者は過度に結合されたアプリケーションを書いてしまう。依存で溢れており、変更に弱い。  
テストを最初に書くことで、それを幾分か緩和できる。テストとは再利用のことであるから、最初にテストを書いてしまうことで、コードに再利用性を持たせることを強制できる効果を得られる。

### どのようにテストするのか

テストを書くときは、テスト対象オブジェクトについての知識以外は持たないようにする。  
テスト対象オブジェクトにのみフォーカスをあてる。

テスト対象オブジェクトの内部にアクセスすることは、結合を強めることを意味する。内部の知識が外に漏れてしまっている。こうなっていると、コードの変更がテストの変更にも波及してしまう可能性が高まってしまう。  
テスト対象オブジェクトの入出力のみを捉えるようにする。

## 9.2 受信メッセージをテストする

[3_1_1.rb](../chapter3/3_1_1.rb)を対象に、受信メッセージのテストについて考える。

`Wheel`は他のオブジェクトに依存していないオブジェクトで、そのテストも依存を持たない。  
他の全てのオブジェクトから独立して、`Wheel#diameter`などの受信メッセージをテストできる。

問題は`Gear`。このオブジェクトは内部で`Wheel`に依存している。具体的には、`gear_inches`メソッドのなかで`Wheel`インスタンスを作成している。  
そのため、この受信メッセージを独立してテストすることは出来ない。`gear_inches`をテストする度に`Wheel`のインスタンスが作成される。  
その結果、テストの実行時間が長くなってしまったり、`Gear`ではなく`Wheel`の問題で`Gear#gear_inches`のテストが壊れてしまったりする可能性がある。

このように、`Gear`のような密結合のオブジェクトは、そのオブジェクトをテストしようとすると他のオブジェクトのコードも実行することになる。  
これは、`Gear`のようなオブジェクトは特定のコンテキストや前提を必要とし、再利用性が低いことを意味している。  
テストを独立して行うことの難しさによって、設計の問題に気付けるのである。

第3章では、依存オブジェクトの注入を行うことで、`Gear`を改善した。  
それが[3_2_1.rb](../chapter3/3_2_1.rb)。

この変更によって、`Gear`が必要なのは`Wheel`インスタンスではなく「`diameter`メソッドを持ったロール」になった。  
このロールを`Diameterizable`を呼ぶことにする。  
`Gear`が必要としているのはこのロールなので、その条件を満たしているのなら何であっても構わない。`Wheel`でもいいし、他の何かでもよい。

テストにも同じことを言える。  
`Gear#gear_inches`をテストする際、`Wheel`のような具象的な実際のオブジェクトを渡すのか、テストのためだけに書かれた、`Diameterizable`を担うフェイクオブジェクトを渡すのか、2つの選択肢が生まれる。

テストのために書かれたフェイクオブジェクトを「テストダブル」と呼ぶ。  
以下は、`Diameterizable`としての条件を満たしたテストダブルの例である。

```ruby
class DiameterDouble
  def diameter
    10
  end
end
```

## 9.3 プライベートメソッドをテストする

原則として、プライベートメソッドをテストする必要はないし、するべきでもない。  
ただし例外もある。

必要な情報が不足しており十分な設計が出来ない場合、その場しのぎの低品質なコードを書いて対応することがある。そして、インターフェースだけ整えて、質の低いコードをプライベートメソッドに隔離する。  
このような状況においては、プライベートメソッドのテストを書くことに価値がある可能性がある。

変更によって破壊が生じたかどうかは、パブリックインターフェースのテストが検知してくれるので、そのためにプライベートメソッドのテストを書く必要はない。  
プライベートメソッドのテストは、エラーのより詳細な情報を示し、変更の影響を理解しやすくしてくれる効果がある。  
これは、リファクタリングの支えとなる。低品質なコードはいずれリファクタリングされることが予定されており、プライベートメソッドのテストはそのための障壁を下げてくれる効果がある。

## 9.4 送信メッセージをテストする

送信メッセージは、クエリメッセージとコマンドメッセージに大別できる。

クエリメッセージとは、副作用のない送信メッセージであり、これについてテストする必要はない。  
例えば`Gear#gear_inches`メソッドは`diameter`を送っているが、この送信メッセージに副作用はない。`Gear`はこの戻り値を必要とするが、他のオブジェクトには一切関係がない。

```ruby
def gear_inches
  ratio * wheel.diameter
end
```

そして、`diameter`の戻り値が正しいものであることの責務は`Wheel`にあるのであり、そのためのテストは`Wheel`の受信メッセージのテストとして既に書かれてある。  
そのため、クエリメッセージとしての`diameter`のテストを書くことは重複であり、不必要な作業となる。

副作用のある送信メッセージであるコマンドメッセージは、テストが必要。  
以下の`observer.changed`はコマンドメッセージの例で、`Gear`はこのメッセージを送ることに責任を持っている。  
コグやチェーンリングが変わった際にこのコマンドメッセージを送信しないと、アプリケーションは正しく動かない。そのため、テストが必要である。

```ruby
class Gear
  attr_reader :chainring, :cog, :wheel, :observer
  def initialize(args)
    # 省略
    @observer = args[:observer]
  end

  # 省略

  def set_cog(new_cog)
    @cog = new_cog
    changed
  end

  def set_chainring(new_chainring)
    @chainring = new_chainring
    changed
  end

  def changed
    observer.changed(chainring)
  end
end
```

テストするべきなのは、`observer`に`changed`メッセージを送信することのみ。その戻り値については`observer`のテストで行うので、`Gear`のテストで行ってはいけない。

このようなテストには「モック」を利用する。モックは、振る舞いのテストのために用いられる。
