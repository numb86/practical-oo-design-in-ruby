# 第4章 柔軟なインターフェースをつくる

オブジェクト指向アプリケーションは、メッセージによって定義される。  
設計においては、オブジェクト間で受け渡されるメッセージについても考慮しなければならない。  
オブジェクト間の会話は「インターフェース」を介して行われる。  
この章では、柔軟なインターフェースの作成を目指す。

## 4.1 インターフェースを理解する

オブジェクトがお互いを知りすぎていると、再利用が困難になってしまう。  
アプリケーション全体が1つのオブジェクトのようになっており、何かを変更すればその変更は他のオブジェクトにも波及してしまう。

だから、クラスが持っているメソッドのうち、どれを外部に晒すかが重要になる。

## 4.2 インターフェースを定義する

クラスのインターフェースは、パブリックインターフェースとプライベートインターフェースの2つに分かれる。

パブリックインターフェースは、パブリックなメソッドで構成される。  
パブリックメソッドは、外部から利用されることを想定しており、変更が起きにくいことが期待されている。

プライベートインターフェースは、プライベートなメソッドで構成される。  
プライベートメソッドは、外部から利用されることを想定していない。また、安定せず変更が起きやすい。

## 4.3 パブリックインターフェースを見つける

インターフェースの良し悪しの判断にも、今までと同じ物差しを使う。  
つまり、現時点での要求に応えつつ、将来の変更にも応えられるようなコードになるかどうか。  
よいパブリックインターフェースは変更に伴うコストを下げるが、悪いパブリックインターフェースはそれを上げてしまう。

コードを書き始める前にまず、ユースケース（要件）を満たすためにどんなオブジェクトとメッセージが必要かを洗い出すべき。  
それを試行錯誤し、それについて他の開発者と意思疎通するための便利なツールが、シーケンス図。

参考: [シーケンス図 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9%E5%9B%B3)

シーケンス図を描くことでオブジェクト間でやり取りしているメッセージが明記され、それが、メッセージの内容やメッセージを送る相手が妥当かを考えるキッカケになる。

そして、シーケンス図を描くことで、フォーカスがクラスからメッセージに移る。  
設計において重要なのは、クラスよりもメッセージ。メッセージに基づく視点は、クラスに基づく視点よりも、柔軟なアプリケーションを生み出す。

なぜなら、まず送るべきメッセージがあり、それの受け手としてオブジェクトがあるから。  
**オブジェクトが存在するからメッセージを送るのではなく、メッセージを送るためにオブジェクトが存在するのである。**

では、どんなメッセージを送るべきなのか。  
それを見極めるためには、「どのように」と「何を」の違いを認識していることが大切。

メッセージは、何をして欲しいかを受け手に伝えるべきであって、どのように振る舞ってほしいかを伝えてはいけない。  
後者は、実装の詳細に立ち入り過ぎており、相手のことを知り過ぎてしまっている。そのようなメッセージに応答するためには多くのパブリックメソッドを作ることになり、パブリックインターフェースは大きく不安定なものになってしまう。  
メッセージを送る側のオブジェクトも、文脈に依存してしまい、再利用が低くなってしまう。

「何を」を軸にしてメッセージについて考えることで、それぞれのオブジェクトが持つべき責務や知るべき内容についても見えてくる。  
どのようなメッセージを送るべきかが分かると、どのようなオブジェクトが必要なのかにも気付ける。

## 4.4 一番良い面（インターフェース）を表に出すコードを書く

インターフェースこそが、アプリケーションを定義し、その将来を決定づける

パブリックインターフェースを構成するメソッドは、以下のようなものであるべき。

- パブリックインターフェースであることが明示的である
- 実装（どのように）ではなく機能や役割（何を）に意識を向けている
- 名前は可能な限り変わらないようにする
- オプション引数はハッシュで受け取る

他のクラスと共同作業をする場合は、そのクラスのパブリックインターフェースのみを使うようにする。  
プライベートインターフェースに依存しなければならなくなった場合、それを回避できないか設計を再考する。  
依存を回避できない場合も、その依存を隔離するための努力は行うべき。依存の隔離については第3章で説明した。

メッセージの送り手が、実装の詳細を知ることなく利用できる。そのようなパブリックインターフェースを構築するべき。

まともなパブリックインターフェースを持たないクラスに遭遇しても、諦めてはいけない。  
自身の手でパブリックインターフェースを作る。  
やり方はいろいろある。新しくパブリックメソッドを定義してもいいし、ラッパークラスを作ってもいい。メッセージを送る側のクラスのなかにラッパーメソッドを作る方法もある。

## 4.5 デメテルの法則

デメテルの法則は、オブジェクトを疎結合にするためのテクニック。  
疎結合であることは美徳とされるが、設計の一要素に過ぎないので、他の要素とのバランスを考えなければならない。  
デメテルの法則も同様で、必ず法則を守らなければならないわけではない。トレードオフを検討し、選択する。

デメテルの法則は、「型の異なるオブジェクトでメッセージチェーンを作ること」を禁じる。  
例えば`customer.bicycle.wheel.rotate`というコードがあったとき、これはデメテルの法則に違反している。

このようなコードは、変更コストの上昇を引き起こす。  
さらに、再利用性が低い。特定の実装について知り過ぎており、それに依存しすぎている。このコードを使っているメソッドは必ず`customer`を必要とするだけでなく、その`customer`は`bicycle`を持っていなければならず、さらに`bicycle`は「`rotate`させることが出来る`wheel`」を持っていなければならない。

既に述べたように、デメテルの法則を守るべきかどうかは、あくまでもトレードオフのなかで判断することである。  
デメテルの法則の意義は、それを意識することが柔軟なパブリックインターフェースの構築につながる、ということにある。
`customer.bicycle.wheel.rotate`のようなメッセージチェーンが現れてしまうときは、必要なパブリックインターフェースが欠けている可能性がある。  
メッセージに基づいて設計すれば、適切なパブリックインターフェースが浮かび上がり、パブリックインターフェースを再構築できる。  
デメテルの法則を意識することで、視点の誤りに気付き、設計を見直す機会を得られる。

## 4.6 まとめ

オブジェクト指向アプリケーションは、オブジェクト間のメッセージの受け渡しによって定義される。  
メッセージ交換は、パブリックインターフェースを介して行われる。

適切に設計されたパブリックインターフェースは変更コストが低く再利用性が高いものになる。  
それを作るためのコツは、オブジェクトではなくメッセージに集中すること、そしてメッセージを「振る舞い」ではなく「何を望むか」を伝えるようなものにすること、である。
